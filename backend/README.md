# Backend — Movie App API

GraphQL API server for the Movie App. Fetches movie data from TMDB, manages user reviews in PostgreSQL, and authenticates via Auth0 JWTs.

---

## Stack

| Component | Technology |
|-----------|-----------|
| Runtime | Bun |
| Language | TypeScript (strict mode) |
| HTTP Server | Fastify 5 |
| API Layer | Apollo Server 4 (GraphQL) via `@as-integrations/fastify` |
| ORM | Prisma 6 |
| Database | PostgreSQL 16 |
| Auth | Auth0 JWT validation (`jwks-rsa` + `fast-jwt`) |
| Monitoring | Sentry |
| Node target | 22 LTS |

---

## Architecture

3-layer architecture with clear separation of concerns:

```
src/
├── schema/resolvers/    ← RESOLVERS (Controller Layer)
│                          - GraphQL entry points
│                          - Auth checks (is user logged in?)
│                          - Input validation
│                          - Delegates to services
│
├── services/            ← SERVICES (Business Logic Layer)
│                          - Orchestrates operations
│                          - Sentry error tracking & breadcrumbs
│                          - Calls repositories for DB ops
│                          - Calls TMDBService for external data
│
├── repositories/        ← REPOSITORIES (Data Access Layer)
│                          - Prisma queries only
│                          - No business logic
│                          - One repository per DB model
│
└── services/tmdb.service.ts  ← EXTERNAL API CLIENT
                                - TMDB API calls
                                - In-memory caching (node-cache)
```

### Why no separate controllers/, models/, or dtos/?

In GraphQL, Apollo Server handles request parsing, routing, and response formatting — the things controllers exist for in REST. Resolvers receive typed `args` and `context` directly, making a separate controller layer redundant pass-through code.

| Traditional layer | GraphQL equivalent |
|-------------------|--------------------|
| Controllers | **Resolvers** — already receive parsed, typed input from Apollo |
| Models | **Prisma-generated types** — `Prisma.User`, `Prisma.Review` etc. |
| DTOs | **GraphQL `input`/`type` definitions** — the schema itself defines API shapes |
| Mappers | **Inline in services** — transformations are simple enough to live where they're used |

If the codebase grows and any of these warrant extraction, we add the layer then.

### Data flow example: "User creates a review"

```
1. createReview mutation hits review.resolver.ts
2. Resolver checks context.user exists (auth guard)
3. Resolver calls reviewService.create(userId, input)
4. Service validates rating is 1-10
5. Service calls userRepository.findById(userId) to verify user
6. Service calls reviewRepository.create(data)
7. Repository executes Prisma insert
8. Service logs breadcrumb to Sentry
9. Resolver returns the created Review
```

---

## Folder Structure

```
backend/
├── package.json
├── tsconfig.json
├── prisma/
│   ├── schema.prisma              # Database models (User, Review)
│   └── migrations/                # Auto-generated by Prisma
│
└── src/
    ├── index.ts                   # Entry point: Fastify + Apollo Server startup
    ├── instrument.ts              # Sentry SDK init (imported before everything else)
    │
    ├── config/
    │   ├── env.ts                 # Validates & exports typed env vars
    │   ├── database.ts            # Prisma client singleton
    │   └── auth.ts                # Auth0 JWKS config + JWT verification setup
    │
    ├── schema/
    │   ├── typeDefs/
    │   │   ├── index.ts           # Merges all .graphql files
    │   │   ├── movie.graphql      # Movie, Genre, MovieConnection types + queries
    │   │   ├── user.graphql       # User type + me query
    │   │   └── review.graphql     # Review type + queries + mutations
    │   └── resolvers/
    │       ├── index.ts           # Merges all resolvers
    │       ├── movie.resolver.ts  # Trending, popular, search, detail
    │       ├── user.resolver.ts   # me query
    │       └── review.resolver.ts # CRUD mutations + review queries
    │
    ├── services/
    │   ├── tmdb.service.ts        # TMDB API client with in-memory cache
    │   ├── movie.service.ts       # Movie logic (wraps TMDB, attaches reviews)
    │   ├── user.service.ts        # User find-or-create on first auth
    │   └── review.service.ts      # Review CRUD with auth checks + Sentry
    │
    ├── repositories/
    │   ├── user.repository.ts     # Prisma: findByAuth0Id, upsert
    │   └── review.repository.ts   # Prisma: create, update, delete, findByMovie, findByUser
    │
    ├── plugins/
    │   └── auth.plugin.ts         # Fastify plugin: JWT extraction & verification via JWKS
    │
    ├── types/
    │   ├── context.ts             # ApolloContext { user, prisma, services }
    │   └── tmdb.ts                # TMDB API response interfaces
    │
    └── utils/
        ├── errors.ts              # AuthenticationError, ForbiddenError, NotFoundError
        └── logger.ts              # Sentry-backed logger utility
```

### Key change: `middleware/` → `plugins/`

Fastify uses a **plugin system** instead of Express-style middleware. The auth logic registers as a Fastify plugin that runs as an `onRequest` hook, decoding the JWT from the `Authorization` header using `jwks-rsa` (fetches Auth0's public keys) and `fast-jwt` (verifies RS256 signatures). The decoded user payload is attached to the Fastify request object and passed into Apollo's context.

---

## Database Models

### User
| Column | Type | Constraint |
|--------|------|-----------|
| id | cuid | PK |
| auth0_id | string | Unique |
| email | string | Unique |
| name | string | Nullable |
| picture | string | Nullable |
| created_at | timestamp | Default now |
| updated_at | timestamp | Auto-update |

### Review
| Column | Type | Constraint |
|--------|------|-----------|
| id | cuid | PK |
| tmdb_id | int | Indexed |
| rating | int | 1–10 |
| title | string | Nullable |
| body | text | Nullable |
| user_id | string | FK → users, cascade delete |
| created_at | timestamp | Default now |
| updated_at | timestamp | Auto-update |

**Unique:** `(user_id, tmdb_id)` — one review per user per movie

---

## GraphQL API

### Queries

| Query | Auth | Description |
|-------|:----:|-------------|
| `trendingMovies(page, timeWindow)` | No | TMDB trending (day/week) |
| `popularMovies(page)` | No | TMDB popular |
| `searchMovies(query, page)` | No | TMDB search by title |
| `movie(id)` | No | TMDB movie details |
| `reviewsForMovie(tmdbId, page, limit)` | No | Reviews from our DB |
| `me` | Yes | Current user profile |
| `myReviews` | Yes | Current user's reviews |

### Mutations

| Mutation | Auth | Description |
|----------|:----:|-------------|
| `createReview(input)` | Yes | Rate & review a movie |
| `updateReview(id, input)` | Yes | Edit own review |
| `deleteReview(id)` | Yes | Delete own review |

### Auth Behavior
- **No token**: public queries work, `me` returns `null`, mutations throw `UNAUTHENTICATED`
- **Valid token**: user is upserted in DB on first request, all operations available
- **Invalid token**: request continues as unauthenticated (plugin is non-blocking)

---

## TMDB Integration

All movie data is fetched from [TMDB API v3](https://developer.themoviedb.org/reference/intro/getting-started) via `TMDBService`.

| Endpoint | Cache TTL | Usage |
|----------|-----------|-------|
| `GET /trending/movie/{day\|week}` | 10 min | Homepage trending |
| `GET /movie/popular` | 10 min | Popular movies list |
| `GET /search/movie?query=` | 2 min | Search results |
| `GET /movie/{id}` | 10 min | Movie detail page |

- Auth: Bearer token (TMDB v4-style read access token)
- Cache: `node-cache` (in-memory, TTL-based)
- Errors: logged to Sentry, returned as `EXTERNAL_API_ERROR` GraphQL error

---

## Environment Variables

| Variable | Required | Default | Description |
|----------|:--------:|---------|-------------|
| `DATABASE_URL` | Yes | — | `postgresql://user:pass@host:5432/db` |
| `AUTH0_DOMAIN` | Yes | — | e.g. `your-tenant.auth0.com` |
| `AUTH0_AUDIENCE` | Yes | — | e.g. `https://movie-app-api` |
| `TMDB_API_KEY` | Yes | — | TMDB read access token |
| `SENTRY_DSN` | Yes | — | Sentry project DSN |
| `BACKEND_PORT` | No | `4000` | Server listen port |
| `FRONTEND_URL` | No | `http://localhost:3000` | Allowed CORS origin |

Bun loads `.env` automatically — no `dotenv` needed.

---

## Scripts

```bash
bun run dev          # Start dev server with --watch (auto-restart on changes)
bun run build        # Compile TypeScript to dist/
bun run start        # Run compiled JS (production)
bun run db:migrate   # Run Prisma migrations
bun run db:seed      # Seed database
bun run db:studio    # Open Prisma Studio GUI
```

---

## Dependencies

### Production
```
fastify                        # HTTP server
@fastify/cors                  # CORS plugin (replaces standalone cors package)
@apollo/server                 # GraphQL server
@as-integrations/fastify       # Official Apollo ↔ Fastify integration
graphql                        # GraphQL core
graphql-tag                    # gql template literal
@prisma/client                 # Prisma ORM client
@sentry/node                   # Sentry error tracking
jwks-rsa                       # Fetches Auth0 JWKS public keys
fast-jwt                       # RS256 JWT verification (Fastify ecosystem)
node-cache                     # In-memory TTL cache for TMDB responses
```

### Dev
```
typescript
@types/node
prisma
```
